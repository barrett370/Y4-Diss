This section of my report contains many 3 dimensional plots. I have included static captures and attempted to capture them at angles which demonstrate the points I am making. I have hosted all 3D plots seen below and they can be found indexed \href{https://barrett370.github.io/Y4-Diss/posts/figures}{here:} https://barrett370.github.io/Y4-Diss/posts/figures.

All raw html files can also be found in the \texttt{site/} and \texttt{docs/} directories of my (now public) repository at: https://github.com/barrett370/Y4-Diss/, commit hash 553b66a10c2a0b8a5b074670c2c80f2ad789c6cb. As well as included in the ``figures'' directory included with this submission

I feel the data is better understood and expressed using these interactive plots.

\section{Genetic Algorithms}
\label{sec:eval:GAs}

The core of my approach to solving the problems outlined in Chapter~\ref{chap:Intro} was creating a Genetic algorithm to evolve populations of candidate routes, returning the fittest once the termination criteria are met.

GAs are transparent but stochastic approaches to optimisation problems. As such, it is much easier to examine the operations and decisions they make compared with \textit{black box} approaches such as neural networks, however due to their random nature, it can be difficult to predict their exact behaviour and results can differ greatly from run to run if the number of generations or population size is too low.

Whilst a poor choice of training data can lead to unintended/ unpredictable behaviour from approaches like neural networks, they have the advantage that most of their compute time is used when constructing the initial model, subsequent usage of these models requires little compute time. Whereas, GAs must run the entirety of the \textit{learning} process from scratch whenever a new route or set of routes is required. In an application where the system sees a high number of unique requests, this compute time can quickly amount to much longer than the training time for a neural network.

\subsection{Genetic Operator Performance}

During development I implemented two different operators in each category, but there are many other approaches proposed in academic literature. Given more time, I would have liked to implement more and present a more empirical evaluation of each.

A complete table of runtime results for each procedure in my PCCGA can be found in Table~\ref{app:tab:MARuntime}

\subsubsection{Selection}

In a single generation, over three populations of 15 individuals, my ranked selection operator ran 3 times totalling $75.1\mu s$ or an average of $25 \mu s$ per run, a negligible amount of time relative to the overall runtime.

As you can see in Figure~\ref{fig:selection_eg}, my ranked selection operator performs its task well, removing the obviously less fit individuals in favour of more copies of  fitter ones. This can be seen by the removal of the line that dips below the $x$ axis (in this example the bottom road boundary was defined as $b_{1}(x) = 0 $) and the fact that duplicate routes are found as indicated by the 3rd graph of unique routes showing fewer individuals than the second.

Ranked selection compared with fitness proportional (roulette wheel selection) is much more predictable. However, fitness proportional selection may not explore as much of the search space but it is more likely to thoroughly explore a single area. Most other selection operators seem to focus on maintaining a diverse population so as to not get stuck in local minima.

Ranked selection performs best when the fitness of the population is not very diverse. As such performs best in easier situations or in later generations.

It may be possible to implement one of the most advanced hybrid approaches in which the manner in which selection occurs changes as the number of generations increases.

\subsubsection{Mutation}

The mutation operators I implemented were Uniform and Gaussian.

I found Gaussian to perform better in cases where a route may be close to optimal in the phenotypic space, i.e. with minimal changes to trajectory, it would be optimal. In such cases the genotypic fitness may not accurately represent this, a route that collides with another or passes through infeasible space will suffer from a large genotypic fitness penalty possibly encouraging it to be removed from the \textit{gene pool}. Gaussian mutation, preferring mutated points closer to their initial position can be effective as moving such routes closer to an optima.

However, in cases where the initial population generation has created all routes far from the optimal, Gaussian mutation can struggle to generate mutated points extreme enough to direct the GA towards the minima.

Part of the problem with Gaussian mutation, and mutation in general on $n$-degree Bezier curves, is that even a relatively major control point movement may cause only minor changes to the overall trajectory of the curve in cases where $n$ is high.

An example of a relatively large control point mutation leading to a minor direction change can be seen in Figure~\ref{fig:gauss_mutation_eg}.

It is possible that an approach incorporating a form of Simulated Annealing could help to broadly explore the search space in early generations before refining solutions in a found minima in latter generations. This could operate by applying a different mutation operator such as Uniform mutation in the first 60\% of generations before swapping to Gaussian when we would expect our algorithms to have found some local minima.

In a single generation, over the same 3 sets of 15 individuals, my Gaussian mutation operator ran 3 times totalling $1.71 ms$ runtime, an average of $571\mu s$. This is an insignificant amount of time when compared to the overall runtime of this task which stands at $14.4s$.

\subsubsection{Crossover}

I implemented both single point and $k$ point crossover. I ran my benchmarks using single point crossover in an attempt to minimise the amount of randomness and differences in convergence speed between samples.

Simple crossover amounted for a insignificant proportion of the runtime of 3 sets of 15 agents over a single generation, totalling 0.01\% of the runtime at 1.14ms, averaging $381\mu s$ on each of its 3 runs.

$k$ point crossover has little additional runtime complexity, essentially applying the simple crossover operator $k$ times, although in practice the runtime isn't this simple due to the random nature of the $k$ value.


\subsubsection{Fitness}

As previously mentioned the most important operator, and the one I spend the most time working on, is the fitness function.

This acts as the objective function for the algorithm as it seeks to minimise its value across multiple agents over multiple generations.

This operation, especially when modified to detect collisions, was the source of most of the runtime of my project. In the toy example of 3 sets of 15 agents across a single generation, the fitness function accounted for a large proportion of the runtime at $14.4$ across 3 calls, an average of $4.81$ seconds per invocation. This is after all my attempts to speedup the process (See Section~\ref{subsec:approach:bezInt}).

The final incarnation of my fitness function can be thought of as two separate parts:

\begin{enumerate}
  \item The \textit{base fitness} i.e. the fitness when considered in isolation in the road space.

        This calculation again can be thought of as being comprised of 3 parts as outlined in Equation~\ref{eq:basefitness}:

        In total this portion of the function ran 135 times in an average of $55.9ms$ for a total of 52.3\% of the fitness function runtime

        \begin{enumerate}
          \item Route length

                This procedure had an average runtime of around $5.36\mu s$, running 135 times it amounted for $0.01$\% of the fitness function runtime.

          \item Infeasible distance length taking an average of $32.7ms$ to run over its 135 runs, making up $30.6$ of the fitness function runtime.
          \item Close proximity distance length took an average of $23.2ms$ over 135 runs totalling $21.7$\% of the runtime

        \end{enumerate}


  \item The collision penalty

        Collision detection as previously stated was a major source for complexity in my project. However, after a lot of tweaking and time saving measures, in this toy example the runtime for the collision detection stands at an average of $24.8$ms, around the same as the runtime of the high proximity distance calculation.
\end{enumerate}


\section{Bézier Curves}
\label{sec:eval:bezier}

Bézier curves have been utilised in this project to encode and represent the route of a vehicle. As mentioned in Section~\ref{sec:back-bezier-curves}, there are many reasons I originally selected them for this task. However, over the course of implementation and testing, a number of downsides have been presented.

One such downside is that objective numerical approaches with Bézier curves are often complicated, expensive and do not generalise well to $n$ control points.

This leads to many heuristics, and approximations being employed to save computation. Approximations and assumptions in a system as the one proposed in this report, are sub-optimal and could potentially lead to undesired behaviour, which could ultimately have dire consequences if such a system were to be deployed.

Other research such as that by Cai \& Peng\cite{caiCooperativeCoevolutionaryAdaptive2002} takes a different approach, using discrete, grid-based search spaces in which routes are made up of a series of connected straight line segments. This approach removes much of the complexity from my solution but introduces its own concerns.

The routes generated by Cai \& Peng's approach are intended to be executed by autonomous robots, so no thought has been given to potential passengers. Consequently, these routes would require smoothing as a post-planning process, re-introducing complexity.

Another possible representation is the approach taken by Cruz-Piris et al.\cite{cruz-pirisAutomatedOptimizationIntersections2019} which involved representing the section of road, in their case an intersection, as a cellular automata in which a single vehicle can occupy a single cell at any given point in time.

There were however, also some advantages and nice properties of Bézier curves which lent themselves to the task.

Their relatively simple abstract construction as a series of control points proved easy to represent concretely as a genotype. This made the creation of the various genetic operators relatively simple, requiring little pre or post-processing.

They are also capable of representing a high complexity of curve in a relatively simple and concise manner. This makes code much more approachable and algorithms easier to digest.

\section{Single Agent Planning}

The majority of the components of my single agent planning system have been evaluated in Sections~\ref{sec:eval:GAs} and \ref{sec:eval:bezier}. Here I will discuss its overall effectiveness and any possible extensions that could be implemented given more time.


\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.14]{figures/sa-diff1.png}
  \caption{\label{fig:sa-col} Single agent planning: number of generations against size of population against planning time (left), fitness (right), over \textit{easy} road space (Figure~\ref{subfig:sa-road1})}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.2]{figures/sa-diff2.png}
  \caption{\label{fig:sa-diff2} Single agent planning: number of generations against size of population against planning time (left) /s, fitness (right), over \textit{moderately difficult} road space (Figure~\ref{subfig:sa-road2})}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.2]{figures/sa-diff3.png}
  \caption{\label{fig:sa-diff3} Single agent planning: number of generations against size of population against planning time (left) /s, fitness (right), over \textit{difficult} road space (Figure~\ref{subfig:sa-road3})}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.15]{figures/sa-diff4.png}
  \caption{\label{fig:sa-diff4} Single agent planning: number of generations against size of population against planning time (left) /s, fitness (right), over \textit{difficult} road space (Figure~\ref{subfig:sa-road4})}
\end{figure}

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/sa-road1.png}
    \caption{\label{subfig:sa-road1}Easiest road segment, no obstacles, straight}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/sa-road2.png}
    \caption{\label{subfig:sa-road2}Second easiest road segment, single, small obstacle in a straight road. Approx. 4\% of road is infeasible}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/sa-road3.png}
    \caption{\label{subfig:sa-road3}Road segment with single, large obstacle in a straight road. Approx. 12.5\% of road is infeasible.}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/sa-road4.png}
    \caption{\label{subfig:sa-road4}Road segment with single, medium sized obstacle in a curved road. Approx. 4.9\% of road is infeasible.}
  \end{subfigure}
  \caption{\label{fig:single-agent-roads} Roads used to test single agent planner performance, start and goal positions shown, ordered in terms of difficulty}
\end{figure}

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/sa-diff1-cps.png}
    \caption{\label{subfig:sa-diff1-cps}Average number of control points in routes for Road~\ref{subfig:sa-road1}}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/sa-diff2-cps.png}
    \caption{\label{subfig:sa-diff2-cps}Average number of control points in routes for Road~\ref{subfig:sa-road2}}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/sa-diff3-cps.png}
    \caption{\label{subfig:sa-diff3-cps}Average number of control points in routes for Road~\ref{subfig:sa-road3}}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/sa-diff4-cps.png}
    \caption{\label{subfig:sa-diff4-cps}Average number of control points in routes for Road~\ref{subfig:sa-road4}}
  \end{subfigure}
  \caption{\label{fig:single-agent-cps} Average solution complexity for a single agent over a varying number of generations and sizes of populations across various roads }
\end{figure}


In general, I feel that my single agent planner performs well\footnote{\textbf{Note:} all data used in creating the figures referenced in this section can be found in the \textit{sa-all-data.csv} file included with this report }. In a road space such as the one shown in Figure~\ref{subfig:sa-road1} my algorithm converges to within 10\% of the fitness of a direct line between the start and goal point within 2 generations over 3 individuals as seen in Figure~\ref{fig:sa-col}.

As the road space complexity increases (See Figures~\ref{subfig:sa-road2},\ref{subfig:sa-road3}), the speed at which my algorithm convergence is reduced.

Over the road space seen in Figure~\ref{subfig:sa-road2}, this is only by a small margin, taking closer to 3 generations (See Figure~\ref{fig:sa-diff2}).

However, on a more difficult example such as that seen in Figure~\ref{subfig:sa-road3}, all routes close to a straight line are infeasible, resulting in a lower average fitness as can be seen in Figure~\ref{fig:sa-diff3}, as well as a higher average planning time as it is required to perform more involved infeasible distance calculations more often.

On the example road shown in Figure~\ref{subfig:sa-road4}, the algorithm converges slower still, but still reaching what I would consider to be a \textit{good} solution within 5 generations with a population size around 7, these results can be seen in Figure~\ref{fig:sa-diff4}. In terms of planning time, with a few anomalous exceptions planning time steadily increases roughly proportionally to (the number of generations $\times$ the population size).

In general, the analysis of the planning time for my algorithm is difficult due to the inherent stochastic nature of Genetic algorithms. As such, you may notice many erroneous spikes in seemingly random places across the results surfaces, however, in all cases a general upward trend in planning time is seen.

In Figure~\ref{fig:single-agent-cps}, you can see the relationship between solution complexity (quantified by the average number of control points in the fittest solution), number of generations, size of population and difficulty of road section. Generally, in all subfigures, you can see a trend to lower solution complexity as the number of generations increases. This would make sense as the GA has had more opportunity to explore the search space, settling on a more optimal solution. This could be potentially aided by incorporating a measure of solution complexity as a penalised component of the fitness function. Whether this would produce intended behaviour warrants further research.

\subsection{Extensions}

The tuning of parameters is something that I feel requires more time and would lead to more consistent and accurate results. An additional extension that would make the generated routes more feasible is to add considerations to the routes velocity profile and turn angles into the fitness function. Generating Bézier curves with these considerations has been done in other research such as that by Chen et al.\cite{chenQuarticBezierCurve2014} in 2014 in which they generate routes whilst considering the route curvature and velocity constraints, fixing the degree of Bézier curves used may have made this task easier in their case.

\subsection{Comparison with other work}

The closest work to my single agent planner is that outlined by Kala in the 6$^{th}$ chapter of his book ``On-Road Intelligent Vehicles'' in which he details a GA approach using Bézier curves to route a single vehicle through a section of road. It is difficult to directly compare our solutions as Kala does not provide a codified solution and his evaluation does not go into great detail, infact the units are missing from the few graphs he does provide.

Kala does incorporate velocity profiles into his GA, this is an area I have already outline something I would have liked to have added given more time.

Kala's approach seems to rely on much larger populations in order to generate feasible routes, showing a system using Cartesian coordinates (like mine) to require a minimum of 40 individuals to plan a route which did not leave the road-space, as can be seen in Figure~\ref{fig:sa-col}, my solution requires fewer than 10.

The approach seen in the paper from Elshamli et al.\cite{elshamliGeneticAlgorithmDynamic2004} also did not provide concrete results and as such I struggle to directly compare our approaches. A key factor in their path planning was the path \textit{smoothness}, their routes were made up of straight sections between nodes, not unlike the control points used to form a Bézier curve. Their \textit{smoothness} metric evaluated the angle between the route segments joined by a node, if the angle was too great, it was deemed infeasible and penalised. By virtue of using Bézier curves I feel I have intrinsically included this requirement as by their nature Bézier curves are smooth and continuous, further requirements as to the change in $y$ coordinates could be imposed to ensure turns are not too \textit{tight} .

\section{Cooperative (Multi-agent) Planning}
\label{subsec:eval-cooperativeplanning}

\footnote{All data used in constructing the figures seen in this section can be found in the file 'ma-all-data.csv' included with this report}My solution to the problem of planning $n$ non-colliding routes for $n$ agents was to wrap my existing \texttt{GA} function in a cooperative \textit{layer}. This cooperative layer relied on a function for detecting collisions which had extremely high overhead, at one point causing around 50x slowdown in the running time of the function. Detecting intersections between two Bézier curves is a non-trivial task with the best methods taking the same approach of recursive subdivision that I utilised.

As detailed in Section~\ref{sec:maa}, I attempted to speedup my cooperative planning layer through many different means, including parallelising the entire method as well as individual high-complexity sections such as the Bézier curve intersection function. The system on which I have been benchmarking performance is equipped with 16 cores running at a maximum of 4.2GHz.

Julia also boasts the ability to distribute work across multiple systems over secure shell, this could conceivably allow for on-board vehicle computers to aid in the computation and planning of their own routes. Each individual in a concurrent plan is spawned as a unique threaded task and as such having cores equal to the number of concurrently planned agents is ideal. Julia also has good support for GPU programming through libraries such as \texttt{CUDA.jl}\cite{besard2018juliagpu}, in their 2018 paper Roberge et al.\cite{robergeFastGeneticAlgorithm2018} showed how effective massively parallelising genetic algorithms can be, seeing a 290x speedup when compared to sequential execution on a CPU.\@ These two factors make the relatively high planning times seen in this report potentially immaterial and could allow for much higher numbers of generations or larger populations to be feasible.

I tested my cooperative planning method against the same road sections I used to test the single agent planner and unless stated otherwise tested with 3 agents with start-goal positions seen in Figure~\ref{fig:multi-agent-roads}. In all cases I used Gaussian mutation, ranked selection and simple crossover.

When considering the easiest road section, Figure~\ref{subfig:ma-road1}, the average fitness of individuals at low generations and population size is incredibly high, leading to me thresholding it at 40 when producing Figure~\ref{fig:ma-diff1-lim40}. However, it quickly drops producing \textit{good} solutions with average fitness in the region of 18 to 20 within 4 generations over populations around 5 in size.

Planning time sees typical steady growth as the number of generations and population size increases, peaking at around 1 minute (excluding anomalous results) but averaging closer to 40 seconds at the higher end of population size and generations.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.19]{figures/ma-diff1.png}
  \caption{\label{fig:ma-diff1-lim40} Multi agent planning number of generations against size of population against planning time (left), fitness limited at 40 (right), planning through road seen in Figure~\ref{subfig:ma-road1}}
\end{figure}

On a road with an obstacle (Figure~\ref{subfig:ma-road2}), the result seen in Figure~\ref{fig:ma-diff2-lim40} is achieved. Taking slightly longer to converge to \textit{good} solutions at around 6 generations over 6 population. It appears that the number of generations has more of an effect on fitness with 6 generations over 5 populations showing better results than 4 generations on 7 population. However planning time appears to suffer more from more generations than it does from larger populations.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.19]{figures/ma-diff2.png}
  \caption{\label{fig:ma-diff2-lim40} Multi agent planning number of generations against size of population against planning time (left), fitness limited at 40 (right), planning through road seen in Figure~\ref{subfig:ma-road2}}
\end{figure}


Increasing the difficulty further, over the road seen in Figure~\ref{subfig:ma-road3}, we see a yet slower convergence rate with consistently \textit{good} results appearing after 8 generations over 8 individuals, we do however see the fitness drop steeply between the 7th and 8th generations, much more steeply than in the \textit{easier} road segments. Planning time is significantly higher than in previous tests with an average planning rising to around 3 minutes on high numbers of generations and sizes of populations.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.19]{figures/ma-diff3.png}
  \caption{\label{fig:ma-diff3-lim40} Multi agent planning number of generations against size of population against planning time (left), fitness limited at 40 (right), planning through road seen in Figure~\ref{subfig:ma-road3}}
\end{figure}


When planning on the most difficult road segment (Figure~\ref{subfig:ma-road4}), my approach appears to be much less stable. In Figure~\ref{fig:ma-diff4}, you can clearly see the fitness still peaks above 200 regularly even after a high number of generation and/or population size. Whilst a general trend lower fitness can be seen, the regular spikes mean collisions or intersections with the obstacle are common, producing infeasible routes. Clearly more work is required for my approach to handle these more complex road spaces well, as well as perhaps higher populations / numbers of generations.

Planning time again is seen to trend upwards proportionally with (number of generations $\times$ size of populations), reaching very high planning times peaking at 280 seconds for 10 generations over populations of size 15 although, interestingly this is lower than the times seen when planning for Figure~\ref{subfig:ma-road3}, this may be due to the start and goal positions changing leading to more routes in which collision detection can be exited early, i.e. routes in which intersections occur early in the trajectory. This could also be due to external factors such as increased background load on my system during the planning of Road~\ref{subfig:ma-road3}

When varying the number of agents being concurrently planned for we can see that the planning time steadily increases with each new agent added. In Figure~\ref{fig:ma-vary-a-surf} where the planning time surfaces of runs using 1,2,3 and 4 different agents through the road seen in Figure~\ref{subfig:sa-road1}, the surfaces are shown to layer in order of number of agents, this can be more easily seen in Figure~\ref{fig:ma-vary-a}, in which the average planning time across all generation-population size variations is averaged for each number of concurrently planned agents in the range 1 to 4.

Figure~\ref{fig:ma-vary-a} shows a trend very close to linearly proportional, especially when one considers the amount of extra factors which could be affecting the planning time (system load, randomly generated initial populations, random chances for operator to apply and random extents to which they apply). Each data point in Figure~\ref{fig:ma-vary-a} is the average of 2250 results, this may suggest that at such high sample rates, the (pseudo) random nature of GAs can be thought to \textit{average out} . The trend seems to follow the line $y = 11.2x - 8.6$, implying an additional 11.2 seconds of computation for each added agent. It is difficult to verify this as there are so many subcomponents with varying complexities tied to the number of agents, however, this linear trend is promising as it suggests steady growth in runtime as agents are added rather than a less manageable exponential or even \textbf{NP} time complexity.

As previously mentioned one of the key improvements I made to my initial approach to reduce planning time was re-writing it to take advantage of multiple cores, before this I wrote it to run asynchronously, taking full advantage of the single thread on which it ran. In Table~\ref{tab:PCGA-speedup} you can see a marked difference in average runtime over these different approaches. The average runtime of my final, parallel cooperative coevolutionary genetic algorithm (PCCGA), approach being around 2.6 times faster, when run over the 16-threads of the same CPU with the same 3 agent, single generation, 15 population toy example evaluated earlier.

\begin{table}
  \centering
  \begin{tabular}{|l l l l|}
    \hline
      Procedure &ncalls     &time   &avg\\
      \hline
      Sequential single threaded CCGA       & 3    &97.2s  &32.4s\\
      Async (1 thread) PCCGA                & 3    &86.1s  &28.7s\\
       PCCGA           &3    &37.6s   &12.5s\\
      \hline
    \end{tabular}
    \caption{\label{tab:PCGA-speedup} Comparative runtimes for various incarnations of cooperative planner}
    \end{table}

\subsection{Extensions}

The extensions to this system are much the same as those outlined for the single agent planner: parameter tuning and velocity profiles.

In addition to this there are certain new parameters and values introduced by the cooperative wrapper; the objective size of an agent is something which I have not explicitly fixed, by fixing this value the parameters associated to Beizer curve intersection detection and collision detection could be further refined to give the most accurate result, while minimising runtime.

As well as these improvements, there is the possibility outlined earlier of distributing and/or further parallelising this approach. We have seen a substantial reduction in runtime when increasing the number of available cores by 16, if run over the up to 10752 cores seen on modern enterprise GPUs such as the RTX A6000, even despite the much lower core clocks, we could see an incredible further reduction in runtime. Adding to that the distributed possibilities, the runtime of my current system could potentially become negligible, allowing for more dynamic real-time planning which is able to quickly adapt to unforeseen situations during route execution.

\subsection{Comparisons with other work}

My approach in its current form is much more abstracted from a real-world system than other research such as that by Kala, as mentioned previously, his proposed system incorporated a velocity profile as well as explicit vehicle sizes. His approach to multiple agents also hinged on inter-vehicle communication to plan overtakes as opposed to my approach using a plan-then-execute methodology, with all coordination taking place within the planner and each agent being assigned a completed route once planning has concluded.


Other research such as the work by both Cai \& Peng as well as Crus-Piris et al. took a discrete approach to the search space, both using grids but the latter also utilising cellular automata, this allowed them to avoid the complex calculations and approximations I had to employ when assessing collisions or intersections with infeasible space. I feel that by viewing the road as a discrete search space, you create a need for a lot more post-processing on the routes in order for them to be smooth, possibly invalidating the guarantees given by the planner. By planning smooth, continuous routes directly, I can avoid these issues.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.5]{figures/ma-vary-a.png}
  \caption{\label{fig:ma-vary-a} Varying number of agents being concurrently planned through Road~\ref{subfig:ma-road1}}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.4]{figures/ma-vary-a-surf.png}
  \caption{\label{fig:ma-vary-a-surf} Overlaid surfaces for planning time of 1,2,3 and 4 agents through Road~\ref{subfig:ma-road1} over 10 generations and 1 to 15 population, z= planning time /s}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.19]{figures/ma-diff4.png}
  \caption{\label{fig:ma-diff4} Multi agent planning number of generations against size of population against planning time (left), fitness limited at 300 (right), planning through road seen in Figure~\ref{subfig:ma-road4}}
\end{figure}



\begin{figure}
  \centering
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/ma-road1.png}
    \caption{\label{subfig:ma-road1}Easiest road segment, no obstacles, straight}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/ma-road2.png}
    \caption{\label{subfig:ma-road2}Second easiest road segment, single, small obstacle in a straight road. Approx. 4\% of road is infeasible}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/ma-road3.png}
    \caption{\label{subfig:ma-road3}Road segment with single, large obstacle in a straight road. Approx. 12.5\% of road is infeasible.}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/ma-road4.png}
    \caption{\label{subfig:ma-road4}Road segment with single, medium sized obstacle in a curved road. Approx. 4.9\% of road is infeasible.}
  \end{subfigure}
  \caption{\label{fig:multi-agent-roads} Roads used to test PCCGA planner performance, start and goal positions shown, ordered in terms of difficulty}
\end{figure}

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/ma-road1-eg.png}
    \caption{\label{subfig:ma-road1-eg}Example routes through easy road space, average fitness = 18.0 }
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/ma-road2-eg.png}
    \caption{\label{subfig:ma-road2-eg}Example routes through medium road space, average fitness = 18.4 }
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/ma-road3-eg.png}
    \caption{\label{subfig:ma-road3-eg}Example routes through hard road space, average fitness = 155.8}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/ma-road4-eg.png}
    \caption{\label{subfig:ma-road4-eg}Example routes through hard, curved road space, average fitness = 19.3 }
  \end{subfigure}
  \caption{\label{fig:multi-agent-roads-egs} Examples of routes planned through test road spaces using PCCGA planner}
\end{figure}

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/ma-diff1-cps.png}
    \caption{\label{subfig:ma-diff1-cps}Average number of control points in routes for Road~\ref{subfig:ma-road1}}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/ma-diff2-cps.png}
    \caption{\label{subfig:ma-diff2-cps}Average number of control points in routes for Road~\ref{subfig:ma-road2}}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/ma-diff3-cps.png}
    \caption{\label{subfig:ma-diff3-cps}Average number of control points in routes for Road~\ref{subfig:ma-road3}}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/ma-diff4-cps.png}
    \caption{\label{subfig:ma-diff4-cps}Average number of control points in routes for Road~\ref{subfig:ma-road4}}
  \end{subfigure}
  \caption{\label{fig:multi-agent-cps} Average solution complexity for a 3 agents over a varying number of generations and sizes of populations across various roads (See Figure~\ref{fig:multi-agent-roads}) }
\end{figure}

\section{Macro-level Route planning}

The core of my macro-level planner was the previously evaluated multi-agent system, and as such I will not analyse its running time as the extra operations surrounding the invocations of the cooperative GA contribute relatively little time complexity.

My approach to routing multiple agents through a road network heavily relies on a number of naive assumptions:

\begin{itemize}
  \item The constant uniform velocity profile of all agents

        I have spoken about this assumption when evaluating the multi-agent planner but this wrapper also relies heavily upon it.

        When assessing as to whether agents occupy a road space at the same time it assumes each agent takes the most direct route through any previous road spaces at the same speed at which all other agents navigate their previous road spaces. It therefore reasons that if the length of an agent's previous road space segments is less than another agent's previous distance + the distance of the road in question, they will share it.

        In reality, this question would be much more complicated, it relies on the knowledge of the actual path length of all agents as well as knowledge of their velocity profiles as they execute these routes.

        An extension to take this into account would require an almost complete re-imagining of Algorithm~\ref{alg:pathgrouping}, unless a pessimistic view of route efficiency is maintained.


  \item If two agents are grouped together, sharing a road section, their routes are planned under the assumption that they begin at the start of the road at the same time. Even under the assumption detailed above, this is not accurate. For the system to be extended to allow for agents to start at different points significant changes to the multi-agent planner would be necessary as collisions would need to be ignored until such a time as one agent has \textit{caught up} to another, something that again relies on the implementation of generated variable velocity profiles.

  \item The connections between each road segment are also naively assumed to be non-existent, with one section of road flowing directly into another. Obviously, in the real world, there are a variety of types of junctions linking two stretches of road. However, designing a system which can route traffic through such junctions is a domain unto itself as seen in papers such that by Cruz-Piris et al.\cite{cruz-pirisAutomatedOptimizationIntersections2019} in 2019.
  \item The assignment of goal points in the road space is also not ideal, simply splitting the width of the road between the concurrent agents and spacing them out equally, not taking into account initial start positions which leads to circumstances where an agent must cross the entire road, increasing the complexity of the planning problem an example of this can be seen in Figure~\ref{subfig:macplan-1}.
\end{itemize}

In general, I feel this section of my project was able to demonstrate how my underlying system might perform in a larger-scale environment, separate from the toy examples shown above. It performed well with only 3\% of the overall runtime stemming from the macro-level wrapper, i.e. 97\% of the macro planning time comes from the invocations of the parallel cooperative planner evaluated in Section~\ref{subsec:eval-cooperativeplanning}. It is important to note that the performance of Dijkstra's algorithm is primarily related to the total number of vertices in the graph and as such the more intersections a road network has, the more expensive this wrapper will be, however the sparsity of the graph does also play a role.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/macplan-1.png}
    \caption{\label{subfig:macplan-1}}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/macplan-2.png}
    \caption{\label{subfig:macplan-2}}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/macplan-3.png}
    \caption{\label{subfig:macplan-3}}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/macplan-4.png}
    \caption{\label{subfig:macplan-4}}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/macplan-5.png}
    \caption{\label{subfig:macplan-5}}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/macplan-6.png}
    \caption{\label{subfig:macplan-6}}
  \end{subfigure}
  \begin{subfigure}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figures/macplan-7.png}
    \caption{\label{subfig:macplan-7}}
  \end{subfigure}
  \caption{\label{fig:macro--plans} Example routes planned using macro route planner, example can be seen in detail in Section~\ref{sec:mrp} }
\end{figure}


\section{Codebase Evaluation}

In total my codebase consists of around 2000 lines of Julia, a full breakdown can be seen in Figure~\ref{fig:codebase}

The areas which required the most work were the Bézier intersection procedure, parallelising the cooperative planner, designing the path grouping procedure for the macro level planner and creating the multitude of utility functions for plotting and otherwise visualising the results of the GA(s).

The main body of my GA resembles the shape of the generic genetic algorithm seen in Algorithm~\ref{alg:GenericGA}, and can be seen in Figure~\ref{fig:core-ga}.

The key files of interest in my codebase are:

\begin{itemize}
  \item \texttt{GA.jl} This file contains the main body of both my single agent planner (GA), and my cooperative, sequential planner (CGA)
  \item \texttt{bezier.jl} This file contains my Bézier curve definition and all attributed methods such as bezier intersection (bezInt)
  \item \texttt{GAUtils.jl} this file contains various helper methods used throughout the GA
  \item \texttt{utils.jl}  more miscellaneous helper functions
  \item \texttt{geneticOperators.jl} this file contains the procedures for all of the genetic operators detailed in the above sections.
  \item \texttt{roadNetwork.jl} this file contains the definition of my road network graph, including helper functions for conversion between graphing formats
  \item \texttt{parallelCGA.jl} this contains the body of my PCCGA, (PCGA) along with multiple helper functions and testing infrastructure
  \item \texttt{plottingUtils.jl} this file contains a multitude of plotting and graphing utilities, used to produce the figures seen throughout this paper
  \item \texttt{ftbezier.jl} this file contains the versions of the functions found in \texttt{bezier.jl} written to utilise the libbezier fortran library mentioned earlier.
  \item \texttt{parallelPlanner.jl} this contains the procedures for my macro-level planning, including implementations of Algorithms~\ref{alg:pathgrouping} and ~\ref{alg:mrp}.
  \item \texttt{tests/single-agent-test.jl} this file contains the methods used to collect and visualise the data seen regarding my single agent GA.
  \item \texttt{tests/multi-agent-test.jl} this file contains the methods used to collect and visualise the data seen regarding my PCCGA.
\end{itemize}


\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.2]{figures/core-ga-shape.png}
  \caption{\label{fig:core-ga} Core of my GA, written in Julia \\ \small (Note: x $\rhd$ f $\Leftrightarrow$ f(x))}
\end{figure}



\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.4]{figures/codebase.png}
  \caption{\label{fig:codebase} Codebase statistics, provided by tokei}
\end{figure}


%TC:macro \todo 1

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "report"
%%% End:
